# This rule adds the appropriate flags for building and linking a binary against
# a package that is registered with pkg-config(1). It should be called after any
# assignments to C++FLAGS and LINKLIBS
rule PkgConfig {
    C++FLAGS += ` pkg-config --cflags $(<) ` ;
    LINKLIBS += ` pkg-config --libs $(<) ` ;
}

# On Mac OS X, this rule will instruct the compiler to build against multiple
# architectures and output a universal binary. On other systems, it will safely
# do nothing. It should be called after any assignments to C++FLAGS and LINKLIBS
rule Arch {
    if $(UNIX) && $(OS) = "MACOSX" {
        for i in $(<) {
            C++FLAGS += -arch $(i) ;
            LINKLIBS += -arch $(i) ;
        }
    }
}

# This rule is shorthand for "LINK = $(C++)". Using $(C++) as the linker will do
# the right thing and inline against libstdc++.
rule C++Link {
    LINK = $(C++) ;
}

NotFile test ;
Always test ;

# Similar to the "Main" rule, this rule will build an executable binary from the
# listed objects when jam is invoked as `jam test`.. However, unlike "Main", it
# will then run that binary, displaying the output. If the test binary fails, so
# too will the test target.
rule TestMain {
    TestMainFromObjects $(<) : $(>:S=$(SUFOBJ)) ;
    Objects $(>) ;
}

# Helper for TestMain; do not call directly
rule TestMainFromObjects {
    local _s _t ;

    # Add grist to file names
    # Add suffix to exe

    _s = [ FGristFiles $(>) ] ;
    _t = [ FAppendSuffix $(<) : $(SUFFEXE) ] ;

    # so 'jam test-foo' works when it's really test-foo.exe
    if $(_t) != $(<) {
        Depends $(<) : $(_t) ;
        NotFile $(<) ;
    }
    #Always $(_t) ;

    # make compiled sources a dependency of target
    Depends test : $(_t) ;
    Depends $(_t) : $(_s) ;
    MakeLocate $(_t) : $(LOCATE_TARGET) ;

    Clean clean : $(_t) $(_t).out ;
    Link $(_t) : $(_s) ;
    RunTest $(_t) ;
}

# Helper for TestMain; do not call directly.
actions RunTest {
    ./$(<) >&1 ;
}
